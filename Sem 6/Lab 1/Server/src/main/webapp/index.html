<!doctype html>
<html>

<body>

<style>
    body {
        margin: 0;
    }
</style>
<script src="js/three.js"></script>
<script>

    let camera, scene, renderer;
    let geometry, material, sphere_1, sphere_2;

    let position1 = [-0.5, 0.05];
    let position2 = [0.5, -0.05];

    let mass1 = 10;
    let mass2 = 10;

    let speed1 = new THREE.Vector2( 0.005, 0.0 );
    let speed2 = new THREE.Vector2( -0.001, 0.0 );

    let collided = false;

    init();
    animate();

    function newVO(spee1, spee2, m1, m2) {
        var s1 = new THREE.Vector2(spee1.x, spee1.y);
        var s2 = new THREE.Vector2(spee2.x, spee2.y);
        console.log("--------------------------------");
        s2.multiplyScalar(2 * m2);
        console.log(s2.x + " - " + s2.y);
        s1.multiplyScalar(m1 - m2);
        console.log(s1.x + " - " + s1.y);
        s2.add(s1);
        console.log(s2.x + " - " + s2.y);
        s2.multiplyScalar(1 / (m1 + m2));
        console.log(s2.x + " - " + s2.y);
        return s2;
    }

    function newV(s1, s2, m1, m2) {
        var vect = new THREE.Vector2(sphere_2.position.x - sphere_1.position.x, sphere_2.position.y - sphere_1.position.y);
        var angleM = vect.angle() + (Math.PI / 2);
        // if (angleM >= Math.PI) { angleM -= Math.PI; }

        var sub = s1.length() * Math.cos(s1.angle() - angleM) * (m1 - m2)
        + 2 * m2 * s2.length() * Math.cos(s2.angle() - angleM);

        var x = sub / (m1 + m2) * Math.cos(angleM) + s1.length()
        * Math.sin(s1.angle() - angleM) * Math.cos(angleM + Math.PI / 2);
        var y = sub / (m1 + m2) * Math.sin(angleM) + s1.length()
            * Math.sin(s1.angle() - angleM) * Math.sin(angleM + Math.PI / 2);

        return new THREE.Vector2(x, y);

    }

    function init() {

        camera = new THREE.PerspectiveCamera(
            70, window.innerWidth / window.innerHeight, 0.01, 10);
        camera.position.z = 1;

        scene = new THREE.Scene();

        geometry = new THREE.SphereGeometry(0.1, 32, 32);
        var texture = new THREE.TextureLoader().load( 'textures/sphere.jpg' );
        material = new THREE.MeshBasicMaterial( { map: texture } );

        sphere_1 = new THREE.Mesh(geometry, material);
        scene.add(sphere_1);

        sphere_2 = new THREE.Mesh(geometry, material);
        scene.add(sphere_2);

        sphere_1.position.x = position1[0];
        sphere_1.position.y = position1[1];
        sphere_2.position.x = position2[0];
        sphere_2.position.y = position2[1];

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // speed1 = THREE.Vector2( 0.005, 0.0 );
        // speed2 = THREE.Vector2( -0.005, 0.0 );
    }

    function animate() {

        requestAnimationFrame(animate);

        var value = Math.sqrt(
            Math.pow(sphere_2.position.x - sphere_1.position.x, 2)
            + Math.pow(sphere_2.position.y - sphere_1.position.y, 2));
        console.log(value);
        if ( !collided && (value - 0.2 < 0.00001)) {
            console.log("COLLLLLLLLLIIIIIIIIIDEEEEEEEEEED");
            collided = true;
            var sp1 = speed1, sp2 = speed2;
            console.log(sp1);
            sp1 = newV(speed1, speed2, mass1, mass2);
            console.log(sp2);
            sp2 = newV(speed2, speed1, mass2, mass1);
            speed1 = sp2;
            speed2 = sp1;
        }

        if (collided) {
            console.log(speed1);
            console.log(speed2);
        }

        sphere_1.position.x += speed1.x;
        sphere_1.position.y += speed1.y;

        sphere_2.position.x += speed2.x;
        sphere_2.position.y += speed2.y;


        renderer.render(scene, camera);

    }
</script>
</body>

</html>